<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[inspiration]]></title>
    <url>%2F2018%2F09%2F20%2Finspiration%2F</url>
    <content type="text"><![CDATA[摘录史蒂芬平克在《风格的感觉》一书中指出：写作是个把网状的思考，用树状的语法结构，转换成线性字符串的过程（参见 “The Web, the Tree, and the String” 一章）。 科学革命，实际上并不是“知识的革命”，而是“无知的革命”。最初，也不知道是谁最先承认，人类对重要的问题其实一无所知。科学革命就起步于承认自己的无知。 “男人的极大幸运在于，他，不论在成年还是在小时候，必须踏上一条极为艰苦的道路，不过这是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；她不被要求奋发向上，只被鼓励滑下去到达极乐。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。” ——西蒙娜·德·波伏娃 《第二性》 在某些时刻，生活带来的隐痛会格外强烈。这种隐痛并不撕心裂肺，只是从不消失，偶尔会发作起来，令人无法忍受。你分不清它的产生是因为空虚还是基于平庸。有时候一个玩笑或者一部电影就足以驱散它，但就像蜡烛一般，火灭了，黑暗又悄悄聚拢起来。你知道谁都帮不了自己—— 因为人生永恒的事实是，所有人都是孤身一人。有人选择把自己的人生和他人紧密地捆绑在一起；有人选择沉醉在喜欢的事物里对抗虚无感；有人顺应一切，放弃一切，解构一切。但令人悲哀的是，我们谁也没法真正回避它。只是我们也可以是自己世界的王，即使是孤独的王。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Summary]]></title>
    <url>%2F2018%2F09%2F20%2Fprogram%2F</url>
    <content type="text"><![CDATA[域名解析的一般步骤：chrome浏览器为例,其他浏览器原理相同 Chrome浏览器 会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.baidu.com。 注：我们怎么查看Chrome自身的缓存？可以使用 chrome://net-internals/#dns 来进行查看 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索操作系统自身的DNS缓存,如果找到且没有过期则停止搜索解析到此结束. 注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看 如果在Windows系统的DNS缓存也没有找到，那么尝试读取hosts文件（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求。 它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址）,找根域的DNS地址，就会向其发起请求（请问 www.baidu.com 这个域名的IP地址是多少啊？），根域发现这是一个顶级域com域的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com 这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道www.baidu.com 这个域名的IP地址，但是我知道 baidu.com 这个域的DNS地址，你去找它去，于是运营商的DNS又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问 www.baidu.com 这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了 www.baidu.com 这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了 www.baidu.com 对应的IP地址，该进行一步的动作了。 如果经过以上的4个步骤，还没有解析成功，那么会进行如下步骤: 操作系统就会查找NetBIOS name Cache（NetBIOS名称缓存，就存在客户端电脑中的），那这个缓存有什么东西呢？凡是最近一段时间内和我成功通讯的计算机的计算机名和Ip地址，就都会存在这个缓存里面。什么情况下该步能解析成功呢？就是该名称正好是几分钟前和我成功通信过，那么这一步就可以成功解析。 如果第5步也没有成功，那会查询WINS 服务器（是NETBIOS名称和IP地址对应的服务器） 如果第6步也没有查询成功，那么客户端就要进行广播查找 如果第7步也没有成功，那么客户端就读取LMHOSTS文件（和HOSTS文件同一个目录下，写法也一样）如果第八步还没有解析成功，那么就宣告这次解析失败，那就无法跟目标计算机进行通信。只要这八步中有一步可以解析成功，那就可以成功和目标计算机进行通信。 如何解决Python版本共存问题：一种神奇的解决方式 由于历史原因，Python有两个大的版本分支，Python2和Python3，又由于一些库只支持某个版本分支，所以需要在电脑上同时安装Python2和Python3，因此如何让两个版本的Python兼容，如何让脚本在对应的Python版本上运行，这个是值得总结的。 对于Windows，就有点复杂了。因为不论python2还是python3，python可执行文件都叫python.exe，在cmd下输入python得到的版本号取决于环境变量里哪个版本的python路径更靠前，毕竟windows是按照顺序查找的。 这就带来一个问题了，如果你想用python2运行一个脚本，一会你又想用python3运行另一个脚本，你怎么做？来回改环境变量显然很麻烦。 网上很多办法比较简单粗暴，把两个python.exe改名啊，一个改成python2.exe，一个改成python3.exe。这样做固然可以，但修改可执行文件的方式，毕竟不是很好的方法。 我仔细查找了一些python技术文档，发现另外一个我觉得比较好的解决办法。 借用py的一个参数来调用不同版本的Python。py -2调用python2，py -3调用的是python3. Canvas、SVG和WebGL三者的区别：概述：Canvas 位图，是需要自己画点的白板； SVG 矢量图，是给数据就可以绘制点、线、图形的，基于 XML 的标记语言； WebGL 3D位图，是基于 Canvas 的 3D 框架。 SVG只是一种矢量图形文件格式， 不仅现在的浏览器都支持，很多主流的系统也都支持。可以代替一些图片,多用于图标,以及图表上,优势在于拥有HTML的event事件,交互起来很方便。 Canvas 是HTML5新增的一个元素对象，名副其实就是一个画布，浏览器 js 配有相应的操作api，可以不再依赖其他的API或组件而直接绘图，相当于2D的API。一般用于绘制比较复杂的动画,做游戏之类的,由于canvas是HTML5带的,所以不支持低版本浏览器,特别是IE,canvas只是一个画布,绘制上去的东西,例如图片,都是转换成像素点绘制上去的,所以没有event事件,如果需要添加交互事件,需要自己手动计算绘制的对象所在坐标以及层级,还好这部分有第三方库。基本上除了HTML5游戏,一些酷炫的动画,正常的网页交互很少用到。 WebGL 是以 OpenGL ES 2.0 为基础的一套 浏览器 3D图形API （HTML5），在编程概念上与OpenGL ES 2.0 几乎是完全通用的，同样采用可编程渲染管线，也就是每个顶点的处理受到一小段Vertex Shader代码的控制，每个像素的绘制过程也受到一小段Fragment Shader代码的控制。WebGL主要是3D为主， 不过2D的绘图要求也可以变通来实现。WebGL 无论如何都需要一个显示对象来呈现，这个对象就是 Canvas，仅此而已，WebGL不对Canvas有任何附加的操作API， 那部分属于浏览器js支持的范畴。 可看作能在浏览器上运行的OpenGL,WebGL的HTML节点名称用的也是canvas,但是他的渲染则和canvas不同,他可以支持硬件加速,支持3D,可用于3D游戏的开发,目前很少有3D的HTML5游戏,现在你能看到很多酷炫的图形交互的3D图表,大多用WebGL来渲染的。WebGL 也继承 OpenGL ES 2.0 的兼容性支持能力， 在不同的设备上做有限的支持，需要运行时查询。Three.js、Babylon.js、Blender4Web等是几种知名的 WebGL 开发框架，对 WebGL 基础操作做了大量的封装，可以拿来就用， 即使不了解 WebGL规范的细节。 用 途：Canvas 适用于位图，高数据量高绘制频率（帧率）的场景，如动画、游戏；SVG 适用于矢量图，低数据量低绘制频率的场景，如图形、图表；WebGL 主要用来做 3D 展示、动画、游戏。 深入理解javascript原型，闭包，继承和原型链待补充 一切（引用类型）都是对象，对象是属性的集合。undefined, number, string, boolean属于简单的值类型，通过typeof来判断；函数、数组、对象、null都是引用类型，通过instanceof来判断。对象里面的一切都是属性，只有属性，没有方法，它的属性表示为键值对的形式。一切引用类型都是对象，对象都是通过函数来创建的。 prototype原型每一个函数都有一个属性叫做prototype，每一个对象(也包括函数)都有一个属性叫做proto，其实可以把proto叫做隐式原型。 每一个函数的prototype属性值是一个对象（属性的集合，再次强调！），默认的只有一个叫做constructor的属性，指向这个函数本身。每一个对象都有一个属性叫做proto，指向创建该对象的函数的prototype。但是Object.prototype确实一个特例——它的proto指向的是null。 原型链和继承访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找，这就是原型链。根据原型链可以确定继承关系。由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to My Blog! This is my very first blog based on Hexo. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
